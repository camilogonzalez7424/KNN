# -*- coding: utf-8 -*-
"""KNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/MarcoFidelVasquezRivera/K-nearest-Neighbour/blob/Marco/KNN.ipynb
"""

import numpy as np
import pandas as pd
import sklearn #se importa para obtener un dataset
import matplotlib.pyplot as plt#se importa para poder realizar la gráfica con los datos

from sklearn import datasets
#obtiene los datos desde iris
iris = datasets.load_iris()
iris

X = iris.data[:, :2]
Y = iris.target
plt.scatter(X[:,0],X[:,1])

import math
#definimos la clase KNN
class KNN:

  def __init__(self,k):
    self.k = k

  def euclidean_distance(self, idx1, idx2, data, axis=0):
    """    Returns the euclidean distance between x and y.

            Preconditions:
                    the dimensions of x and y must be the same

            Parameters:
                    x (n-dimensional numpy array): an array of integers
                    y (n-dimensional numpy array): an array of integers
                    axis (int): axis in which we are working

            Returns:
                    int): distance between x and y on the axis axis.
    """
    return np.linalg.norm( data[idx1] - data[idx2], axis=axis)

  def get_k_nearest_neighboors(self, idx, data):
        """
        Returns the K nearest neighboors of the point.

        Preconditions:
                the dimensions of point and the points on data must be the same

        Parameters:
                idx (int): the index of the point which we are going to get the distance with the other points
                data: an n-dimensional numpy array
        Postcondition:
                the distance of this point to itself is not going to be returned
        Returns:
                idxs (int): an array whit the indexes of the k nearest neighboors of the point with index idx.
        """
        # Calculate the distances from datapoint in idx with every other datapoint in data 
        distances = np.array([  self.euclidean_distance(idx, i, data) for i in range(len(data)) ])
        # Maps from distance to the index in data excluding idx
        index_distance = dict((distance, index) for index, distance in enumerate(distances) if index != idx)
        distances = np.delete(distances, idx)
        distances.sort()
        top_k_nearest_neighbors = np.array([ index_distance[distance] for distance in distances])
        response = []

        i = 0
        # This ensures that only non-duplicate indexes are returned
        while len(response) < self.k:
          kth_nearest = top_k_nearest_neighbors[i]
          if kth_nearest not in response:
            response.append(kth_nearest)
          i+=1
        return np.array(response)

  def set_point_target(self,indexes,target_data):
    #falta hacer la documentación
    frequency = dict((k,0) for k in target_data)

    for c in range(indexes.size):
      result = target_data[indexes[c]]
      frequency[result]+=1
    
    most_freq = -1
    classfreq = -1
    for clas,freq in frequency.items():
      if freq > most_freq:
        most_freq = freq
        classfreq = clas

    return classfreq

X.shape

#lo probamos haciendo uso de la base de datos cargada anteriormente
knn = KNN(3)
indexes = knn.get_k_nearest_neighbors(4,X)
#error con algunos números, tira indices repetidos
indexes
#target = knn.set_point_target(indexes,Y)
#y[4] = target
#for i in indexes :
#  if i!=4:
#    print(knn.euclidean_distance(point,X[i]))

#lo probamos haciendo uso de una "base de datos" creada por nosotros
testdb_two = np.array([[40.0,30.4],[4.0,5.0],[3.0,8.0],[4.0,10.2],[20.0,0.0],[3.0,8.1]])
knn.get_k_nearest_neighbors(3,testdb_two)